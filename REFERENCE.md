# Platform Reference

*Version 0.2.0-dev*

The following document outlines the API provided by Platform for writing custom loadouts.

## Index

* Environment
* Options
* "Features"
  - Loadouts/Features
  - Hooks
  - "${@}"
* "Includes"
  - Environment/Options
  - Includes

## Environment

The following environment variables are determined by Platform when it runs and are available for use by custom loadouts:

* [`ARCH`](env/ARCH) - The CPU architecture. Values are `amd64`, `armv6l`, or `armv7l`.
* [`CPU_VENDOR`](env/CPU_VENDOR) - The CPU vendor. Values are blank (if unable to determine), `amd`, or `intel`.
* [`DISTRO`](env/DISTRO) - The operating system distribution. For Linux, this is the name of the Linux distribution, e.g. `Debian`. Possible values are: `CentOS`, `Debian`, `Fedora`, `OpenBSD`, `openSUSE`.
* [`DISTRO_VERSION`](env/DISTRO_VERSION) - The version of the operating system distribution. Values depend on `DISTRO`. The value of `DISTRO_VERSION` on your target systems may be numeric, but be careful using -gt and related tests since the version is not an integer expression for all values of `DISTRO` (e.g. OpenBSD 7.1).
* [`IS_METAL`](env/IS_METAL) - Values are 0 or 1. Value is 0 if the system is detected as being virtualized. Value is 1 if the system is running on "metal" (not virtualized).
* [`KERNEL`](env/KERNEL) - The kernel name. Values are `Linux` or `OpenBSD`.
* [`PACKAGE_MANAGER`](env/PACKAGE_MANAGER) - The system's package manager. Values are `apt` (Debian), `yum`/`dnf` (CentOS/Fedora), `pkg_add` (OpenBSD), and `zypper` (openSUSE).

## Options

The following options, controllable with environment variables, are available:

* [`DEBUG`](option/DEBUG) - This option controls whether additional debugging output should be generated by platform and the features it sets up. Set `DEBUG=1` to enable debugging output. The default value is `DEBUG=0`.
* [`DRY_RUN`](option/DRY_RUN) - Values are 0 or 1. Default 0. Set to 0 to echo and perform setup commands on the system. Set to 1 to just echo the commands instead of performing them. **If your loadout or feature does not support this option, then it should disallow using the features with a guard of some sort (i.e. don't change the user's system if they asked you not to).**
* [`ENABLE_HOOK_WATERMARK`](option/ENABLE_HOOK_WATERMARK) - Values are 0 or 1. Default 0. Set to 1 to enable the `hook/watermark` hook, which makes a record of the setup process. See also `WATERMARK_DIR`.
* [`FEATURE_FILE`](option/FEATURE_FILE) - Value is a path to a file. Default to a file in `/tmp`. Set this option to control where the feature file, which is used to keep track of the progress of the platform setup and is deleted when finished, is written. The user must have access to write to this file.
* [`PLZHELP`](option/PLZHELP) - Value is 0 or 1. Default to 0. Set this option to 0 for normal operation. Set this option to 1 to enable extra logging messages about things that might not be fully tested or finished in the software. Set this option if you would like to help improve the software.
* [`WATERMARK_DIR`](option/WATERMARK_DIR) - Value is a path to a directory. Default to `/usr/local/etc/platform/`. Set this option to control where watermark files are stored which record the versions and loadouts used. See also `ENABLE_HOOK_WATERMARK`.

## "Features"

The general idea of a "feature" applies to several types of scripts used for different purposes, but having similar layout: loadout, feature, and hook scripts. The scripts should perform no action when run with no arguments and, when implemented in POSIX shell (`#!/bin/sh`), should run its arguments received as a command with the syntax `"${@}"`. Any executable file will work as long as it does similar.

### Loadouts/Features

Loadouts and features should be located in a `loadout` or `feature` directory/sub-directory. Here are an example shell script to illustrate the general idea:

```sh
#!/bin/sh

set -eu

# This function should output a series of feature names of features which must
# be FULLY set up BEFORE this feature can be set up.
list_prerequisites() {
    echo "feature/test-prerequisite"
}

# This function should output a series of feature names of features which must
# additionally be set up along with this feature.
list_features() {
    echo "feature/necessary-package"
}

# This function should acquire or unpack the feature.
unpack() {
    echo "I'm running the unpack function!"
}

# This function should build the feature.
build() {
    echo "I'm running the build function!"
}

# This function is called before do_install is called and before the system's
# package manager is run for the feature's packages.
pre_install() {
    # You might emplace configuration files or download the source code for a
    # package.
    echo "I'm running the pre_install!"
}

# This function should install the feature.
do_install() {
    echo "I'm running the do_install hook!"
}

# This function should output a series of package names for the system's
# package manager which should be installed. These will often depend on
# $KERNEL, $DISTRO, $PACKAGE_MANAGER, and other factors.
list_packages() {
    echo "my-favorite-tool"
}

# This function is called after the system's package manager is run for the
# feature.
post_install() {
    # You might start a service or initialize a database.
    echo "I'm running the post_install!"
}

"${@}"
```

Each function is optional, so you can skip clutter that you don't need.

### Hooks

Hooks should be located in a `hook` directory/sub-directory. Hooks are included automatically when a loadout or feature from your custom loadout is used.

```sh
#!/bin/sh

set -eu

# This hook is called as the platform process starts, before any features start
# running.
on_start() {
    # You might clear a directory before proceeding with the set up.
    :
}

# this hook is called as the platform process finishes, after all features are
# finished being set up.
on_finish() {
    # You might send an email to the system administrator with installation
    # details.
    :
}

"${@}"
```

Each function is optional, so you can skip clutter that you don't need.

### "${@}"

For feature scripts implemented in POSIX or similar shells, the script should execute the command `"${@}"` as its final statement to give the platform tools a way to execute the functions contained within. In addition to the functions outlined in the API, the platform tools will also send the shell command `type xyz` where `xyz` is the name of one of the functions. The script should exit with a successful code if the function `xyz` is defined.

### Tips

* Variables don't propagate out from the feature when they are set, since the feature is a script that is run during the setup process. Use an environment variable or an option instead.

## "Includes"

### Environment/Options

Should be located in a `env` or `option` directory/sub-directory. Environment and option script fragments are included automatically when a loadout or feature from your custom loadout is used. These script fragments must be written in POSIX shell since they are directly sourced into the platform script.

Example environment:

```sh
#!/bin/sh

# Make VORBLE_VERSION equal to PLATFORM_VERSION since the main source code is
# maintained in parallel with this custom loadout.
export VORBLE_VERSION="$PLATFORM_VERSION"

if [ "$DEBUG" != "0" ]; then
    echo "VORBLE_VERSION=$VORBLE_VERSION"
fi
```

Example option:

```sh
#!/bin/sh

if [ "${DEBUG+defined}" != "defined" ]; then
    DEBUG=0
fi

if [ "$DEBUG" != "0" ]; then
    echo "DEBUG=$DEBUG"
fi

export DEBUG
```

### Includes

Should be located in a `include` directory/sub-directory and must be implemented as a POSIX shell fragment that implement a function. Here is an example include:

```sh
#!/bin/sh

# Include other functions with . (dot)!
. include/do_something_else

do_something() {
    local VALUE
    for VALUE in "${@}"; do
        do_something_else "$VALUE"
    done
}
```

The convention is to name the function the same name as the file. The path to include an file is relative to the Platform deployment root, so your custom include file would be included like this:

```sh
. mycustomloadout/include/my_cool_function
```
